// Task Manager task pane logic, wired to Excel via Office.js
// Based on the scaffold in Task Manager Excel/addin/taskpane.js

/* global document, Excel, Office */

(function(){
  const qs = (s)=>document.querySelector(s);
  const qsa = (s)=>Array.from(document.querySelectorAll(s));
  let teamMembersLoaded = false;
  let hasUnsavedChanges = false;

  // Email Summarizer API configuration
  // Update this URL when deploying to internal server
  const EMAIL_SUMMARIZER_API_URL = 'http://localhost:5002';

  // Toast notification helper
  function showToast(message, type = 'success') {
    const toast = qs('#toast');
    if (!toast) return;
    toast.textContent = message;
    toast.className = 'toast ' + type + ' show';
    setTimeout(() => {
      toast.classList.remove('show');
    }, 3000);
  }

  // Unsaved changes indicator
  function setUnsavedChanges(unsaved) {
    hasUnsavedChanges = unsaved;
    const indicator = qs('#unsavedIndicator');
    if (indicator) {
      indicator.classList.toggle('visible', unsaved);
    }
  }

  // Track form changes
  function wireChangeTracking() {
    const formElements = qsa('input, select, textarea');
    formElements.forEach(el => {
      el.addEventListener('change', () => setUnsavedChanges(true));
      el.addEventListener('input', () => setUnsavedChanges(true));
    });
    // Also track chip clicks
    qsa('.chip').forEach(chip => {
      chip.addEventListener('click', () => setUnsavedChanges(true));
    });
  }

  // Warn before leaving with unsaved changes
  window.addEventListener('beforeunload', (e) => {
    if (hasUnsavedChanges) {
      e.preventDefault();
      e.returnValue = '';
      return '';
    }
  });

  // Escape HTML helper
  function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = String(text || '');
    return div.innerHTML;
  }

  // Due date warning helper
  function getDueDateWarningClass(deadlineStr) {
    if (!deadlineStr) return '';
    const deadline = new Date(deadlineStr);
    if (isNaN(deadline.getTime())) return '';
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    deadline.setHours(0, 0, 0, 0);
    const diffDays = Math.ceil((deadline - today) / (1000 * 60 * 60 * 24));
    if (diffDays < 0) return 'overdue';
    if (diffDays <= 3) return 'warning';
    return '';
  }

  function formatDeadlineBadge(deadlineStr) {
    const warningClass = getDueDateWarningClass(deadlineStr);
    if (!warningClass) return '';
    if (warningClass === 'overdue') {
      return '<span class="deadline-badge overdue">‚ö†Ô∏è Overdue</span>';
    }
    const deadline = new Date(deadlineStr);
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    deadline.setHours(0, 0, 0, 0);
    const diffDays = Math.ceil((deadline - today) / (1000 * 60 * 60 * 24));
    if (diffDays === 0) return '<span class="deadline-badge warning">‚è∞ Due today</span>';
    if (diffDays === 1) return '<span class="deadline-badge warning">‚è∞ Due tomorrow</span>';
    return `<span class="deadline-badge warning">‚è∞ ${diffDays} days left</span>`;
  }

  // Apply deadline warnings to task cards
  function applyDeadlineWarnings() {
    qsa('.task-card').forEach(card => {
      const deadlineInput = card.querySelector('[data-role="deadline"]');
      if (!deadlineInput) return;
      const deadline = deadlineInput.value;
      const warningClass = getDueDateWarningClass(deadline);
      card.classList.remove('deadline-warning', 'deadline-overdue');
      if (warningClass === 'overdue') {
        card.classList.add('deadline-overdue');
      } else if (warningClass === 'warning') {
        card.classList.add('deadline-warning');
      }
    });
  }

  const companyNameInput = qs('#companyName');
  // taskDescriptionEl is now a container with checkboxes, not a select
  const brokerLeadEl = qs('#brokerLead');
  const initialRequestInput = qs('#initialRequest');
  const introEmailInput = qs('#introEmail');
  const remindersStartInput = qs('#remindersStart');
  const emailFrequencyEl = qs('#emailFrequency');
  const extraNoteEl = qs('#extraNote');
  const auditTextEl = qs('#auditText');
  const tasksRowEl = qs('#tasksRow');
  const taskCardsContainer = qs('#taskCards');
  const taskNameInput = qs('#taskName'); // only for __other__ card

  // Wire Save, New Task, Load Selected, and KYC Portal buttons
  const saveBtn = qs('#saveBtn');
  const newTaskBtn = qs('#newTaskBtn');
  const loadSelectedBtn = qs('#loadSelectedBtn');
  const openKycPortalBtn = qs('#openKycPortal');

  // Track current row for display
  let currentRowNum = null;

  if (saveBtn) {
    saveBtn.addEventListener('click', async () => {
      try {
        if (currentRowNum === null || currentRowNum === 'new') {
          await addNewTask();
          showToast('‚úÖ New task added successfully!', 'success');
        } else {
          await saveToActiveRow();
          showToast('‚úÖ Changes saved to row ' + currentRowNum, 'success');
        }
        setUnsavedChanges(false);
      } catch (e) {
        console.error('Save error:', e);
        showToast('‚ùå Save failed: ' + e.message, 'error');
      }
    });
  }

  // Load Selected Row button (in By Row tab)
  if (loadSelectedBtn) {
    loadSelectedBtn.addEventListener('click', async () => {
      try {
        await loadFromActiveRow();
        showToast('‚úÖ Loaded row ' + currentRowNum, 'success');
      } catch (e) {
        console.error('Load error:', e);
        showToast('‚ùå Failed to load row', 'error');
      }
    });
  }

  if (newTaskBtn) {
    newTaskBtn.addEventListener('click', () => {
      clearFormForNewTask();
    });
  }

  // Custom confirm dialog (since window.confirm is not supported in Office Add-ins)
  function showConfirmDialog(message) {
    return new Promise((resolve) => {
      const dialog = qs('#confirmDialog');
      const msgEl = qs('#confirmMessage');
      const cancelBtn = qs('#confirmCancel');
      const okBtn = qs('#confirmOk');
      
      if (!dialog || !msgEl || !cancelBtn || !okBtn) {
        resolve(false);
        return;
      }
      
      msgEl.textContent = message;
      dialog.style.display = 'flex';
      
      const cleanup = () => {
        dialog.style.display = 'none';
        cancelBtn.removeEventListener('click', onCancel);
        okBtn.removeEventListener('click', onOk);
      };
      
      const onCancel = () => {
        cleanup();
        resolve(false);
      };
      
      const onOk = () => {
        cleanup();
        resolve(true);
      };
      
      cancelBtn.addEventListener('click', onCancel);
      okBtn.addEventListener('click', onOk);
    });
  }

  // Delete Task button
  const deleteTaskBtn = qs('#deleteTaskBtn');
  if (deleteTaskBtn) {
    deleteTaskBtn.addEventListener('click', async () => {
      // Don't allow delete if this is a new unsaved task
      if (currentRowNum === null || currentRowNum === 'new') {
        showToast('No task to delete - this is a new task', 'error');
        return;
      }
      
      // Confirm before deleting
      const confirmed = await showConfirmDialog('Are you sure you want to delete this Task?');
      if (!confirmed) return;
      
      try {
        await deleteCurrentRow();
        showToast('‚úÖ Task deleted successfully', 'success');
        clearFormForNewTask();
      } catch (e) {
        console.error('Delete error:', e);
        showToast('‚ùå Failed to delete task: ' + e.message, 'error');
      }
    });
  }

  // Guard on the DOM element so we don't wire multiple listeners or open twice
  if (openKycPortalBtn && openKycPortalBtn.dataset.kycListenerAttached !== '1') {
    openKycPortalBtn.dataset.kycListenerAttached = '1';
    openKycPortalBtn.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (openKycPortalBtn.dataset.kycOpening === '1') return;
      openKycPortalBtn.dataset.kycOpening = '1';
      window.open('http://192.168.1.141:8080/', '_blank');
      setTimeout(() => { openKycPortalBtn.dataset.kycOpening = '0'; }, 1000);
    });
  }

  // Statistics Navigation
  const tasksView = qs('#tasksView');
  const statsView = qs('#statsView');
  const tasksHeader = qs('#tasksHeader');
  const statsHeader = qs('#statsHeader');
  const openStatsBtn = qs('#openStatsBtn');
  const returnToTasksBtn = qs('#returnToTasksBtn');
  const refreshStatsBtn = qs('#refreshStatsBtn');

  if (openStatsBtn) {
    openStatsBtn.addEventListener('click', () => {
      if (tasksView) tasksView.style.display = 'none';
      if (tasksHeader) tasksHeader.style.display = 'none';
      if (statsView) statsView.style.display = '';
      if (statsHeader) statsHeader.style.display = 'flex';
      loadStatistics();
    });
  }

  if (returnToTasksBtn) {
    returnToTasksBtn.addEventListener('click', () => {
      if (tasksView) tasksView.style.display = '';
      if (tasksHeader) tasksHeader.style.display = 'flex';
      if (statsView) statsView.style.display = 'none';
      if (statsHeader) statsHeader.style.display = 'none';
    });
  }

  if (refreshStatsBtn) {
    refreshStatsBtn.addEventListener('click', () => {
      loadStatistics();
    });
  }

  // Statistics calculation
  async function loadStatistics() {
    try {
      await Excel.run(async (context) => {
        const sheet = context.workbook.worksheets.getItemOrNullObject('TASK MANAGER FORM');
        sheet.load('name');
        await context.sync();
        if (sheet.isNullObject) {
          console.error('Sheet not found for statistics');
          return;
        }

        // Load all data
        const dataRange = sheet.getRange('A1:K5000');
        dataRange.load('values');
        await context.sync();

        const rows = dataRange.values || [];
        if (rows.length < 2) return;

        // Parse all tasks
        const tasks = [];
        let todoCount = 0, inProgressCount = 0, doneCount = 0;
        const brokerStats = {};
        const monthlyStats = {};
        const kycMonthly = {};
        let totalDuration = 0, durationCount = 0;
        
        // Attention items with details
        const overdueItems = [];
        const upcomingItems = [];
        const staleItems = [];

        const today = new Date();
        today.setHours(0, 0, 0, 0);
        const sevenDaysFromNow = new Date(today);
        sevenDaysFromNow.setDate(sevenDaysFromNow.getDate() + 7);
        const thirtyDaysAgo = new Date(today);
        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

        for (let i = 1; i < rows.length; i++) {
          const row = rows[i];
          const company = row[0] ? String(row[0]).trim() : '';
          if (!company) continue;

          const category = row[1] ? String(row[1]).trim() : '';
          const broker = row[3] ? String(row[3]).trim() : '(none)';
          const initialRequest = row[4]; // Column E - Initial Request Date
          const introEmail = row[5]; // Column F - Intro Email Date
          const remindersStart = row[6]; // Column G - Reminders Start Date
          const taskSummary = row[7] ? String(row[7]).trim() : '';

          // Parse dates from columns E, F, G for monthly stats
          // Use the earliest available date as the task creation date
          let taskDate = null;
          const dateE = parseDate(initialRequest);
          const dateF = parseDate(introEmail);
          const dateG = parseDate(remindersStart);
          
          // Pick the earliest non-null date
          const availableDates = [dateE, dateF, dateG].filter(d => d !== null);
          if (availableDates.length > 0) {
            taskDate = availableDates.reduce((min, d) => d < min ? d : min);
          }
          
          if (taskDate) {
            const monthKey = `${taskDate.getFullYear()}-${String(taskDate.getMonth() + 1).padStart(2, '0')}`;
            monthlyStats[monthKey] = (monthlyStats[monthKey] || 0) + 1;
          }

          // Broker stats
          if (!brokerStats[broker]) {
            brokerStats[broker] = { total: 0, active: 0, completed: 0 };
          }
          brokerStats[broker].total++;

          // Parse task summary for status
          if (taskSummary) {
            const lines = taskSummary.split(/\r?\n/).filter(Boolean);
            lines.forEach(line => {
              const lower = line.toLowerCase();
              
              // Count statuses
              if (lower.includes(': to do')) {
                todoCount++;
                brokerStats[broker].active++;
              } else if (lower.includes(': in progress')) {
                inProgressCount++;
                brokerStats[broker].active++;
              } else if (lower.includes(': done')) {
                doneCount++;
                brokerStats[broker].completed++;
              }

              // Check for KYC completed
              if (lower.includes('kyc') && lower.includes(': done')) {
                const completedMatch = line.match(/completed:\s*(\d{1,2}[-\s][A-Za-z]{3}[-\s]\d{2,4})/i);
                if (completedMatch) {
                  const kycDate = parseDate(completedMatch[1]);
                  if (kycDate) {
                    const monthKey = `${kycDate.getFullYear()}-${String(kycDate.getMonth() + 1).padStart(2, '0')}`;
                    kycMonthly[monthKey] = (kycMonthly[monthKey] || 0) + 1;
                  }
                }
              }

              // Extract task name and assignee for attention items
              const taskNameMatch = line.match(/^(.*?)\s*:\s*(to do|in progress|done)/i);
              const assigneeMatch = line.match(/assigned to\s+([^|]+)/i);
              const taskName = taskNameMatch ? taskNameMatch[1].trim() : 'Unknown';
              const assignee = assigneeMatch ? assigneeMatch[1].trim() : '';

              // Check deadlines (support both formats)
              const deadlineMatch = line.match(/deadline:\s*(\d{4}-\d{2}-\d{2}|\d{1,2}[-\s][A-Za-z]{3}[-\s]\d{2,4})/i);
              if (deadlineMatch && !lower.includes(': done')) {
                const deadline = parseDate(deadlineMatch[1]);
                if (deadline) {
                  const daysUntil = Math.ceil((deadline - today) / (1000 * 60 * 60 * 24));
                  if (deadline < today) {
                    overdueItems.push({
                      company,
                      task: taskName,
                      assignee,
                      detail: `${Math.abs(daysUntil)}d overdue`
                    });
                  } else if (deadline <= sevenDaysFromNow) {
                    upcomingItems.push({
                      company,
                      task: taskName,
                      assignee,
                      detail: daysUntil === 0 ? 'Today' : `${daysUntil}d left`
                    });
                  }
                }
              }

              // Check for stale tasks (no status update for 30+ days, not Done)
              if (!lower.includes(': done')) {
                // Look for the last action date (initiated, updated, or completed)
                const initiatedMatch = line.match(/initiated:\s*(\d{1,2}[-\s][A-Za-z]{3}[-\s]\d{2,4})/i);
                const updatedMatch = line.match(/updated:\s*(\d{1,2}[-\s][A-Za-z]{3}[-\s]\d{2,4})/i);
                
                let lastActionDate = null;
                if (updatedMatch) {
                  lastActionDate = parseDate(updatedMatch[1]);
                } else if (initiatedMatch) {
                  lastActionDate = parseDate(initiatedMatch[1]);
                }
                
                if (lastActionDate && lastActionDate < thirtyDaysAgo) {
                  const daysSince = Math.ceil((today - lastActionDate) / (1000 * 60 * 60 * 24));
                  staleItems.push({
                    company,
                    task: taskName,
                    assignee,
                    detail: `${daysSince}d ago`
                  });
                }
              }

              // Calculate duration for completed tasks
              if (lower.includes(': done')) {
                const initiatedMatch = line.match(/initiated:\s*(\d{1,2}[-\s][A-Za-z]{3}[-\s]\d{2,4})/i);
                const completedMatch = line.match(/completed:\s*(\d{1,2}[-\s][A-Za-z]{3}[-\s]\d{2,4})/i);
                if (initiatedMatch && completedMatch) {
                  const initiated = parseDate(initiatedMatch[1]);
                  const completed = parseDate(completedMatch[1]);
                  if (initiated && completed) {
                    const days = Math.ceil((completed - initiated) / (1000 * 60 * 60 * 24));
                    if (days >= 0 && days < 365) {
                      totalDuration += days;
                      durationCount++;
                    }
                  }
                }
              }
            });
          }
        }

        // Update UI
        const activeTasks = todoCount + inProgressCount;
        qs('#statActiveTasks').textContent = activeTasks;
        qs('#statAvgDuration').textContent = durationCount > 0 ? Math.round(totalDuration / durationCount) : '-';

        // Status bars
        const totalStatus = todoCount + inProgressCount + doneCount;
        if (totalStatus > 0) {
          qs('#barToDo').style.width = (todoCount / totalStatus * 100) + '%';
          qs('#barInProgress').style.width = (inProgressCount / totalStatus * 100) + '%';
          qs('#barDone').style.width = (doneCount / totalStatus * 100) + '%';
        }
        qs('#countToDo').textContent = todoCount;
        qs('#countInProgress').textContent = inProgressCount;
        qs('#countDone').textContent = doneCount;

        // Attention Required section - render counts and task lists
        // Helper to render attention items and show/hide group
        const renderAttentionGroup = (items, groupId, listId, countId) => {
          const group = qs(`#${groupId}`);
          const container = qs(`#${listId}`);
          const countEl = qs(`#${countId}`);
          
          if (countEl) countEl.textContent = items.length;
          
          if (!group || !container) return;
          
          if (items.length === 0) {
            group.classList.remove('has-items');
            container.innerHTML = '';
            return;
          }
          
          group.classList.add('has-items');
          // Format: "Company: Task to Assignee" with detail on right
          container.innerHTML = items.slice(0, 10).map(item => {
            const assigneePart = item.assignee ? ` <span class="to-assignee">to ${escapeHtml(item.assignee)}</span>` : '';
            return `<div class="attention-item">
              <span class="task-info" title="${escapeHtml(item.company)}: ${escapeHtml(item.task)}">${escapeHtml(item.company)}: ${escapeHtml(item.task)}${assigneePart}</span>
              <span class="task-detail">${escapeHtml(item.detail)}</span>
            </div>`;
          }).join('');
        };
        
        // Sort and render each list
        overdueItems.sort((a, b) => parseInt(b.detail) - parseInt(a.detail)); // Most overdue first
        upcomingItems.sort((a, b) => parseInt(a.detail) - parseInt(b.detail)); // Soonest first
        staleItems.sort((a, b) => parseInt(b.detail) - parseInt(a.detail)); // Oldest first
        
        renderAttentionGroup(overdueItems, 'overdueGroup', 'overdueList', 'statOverdue');
        renderAttentionGroup(upcomingItems, 'upcomingGroup', 'upcomingList', 'statUpcoming');
        renderAttentionGroup(staleItems, 'staleGroup', 'staleList', 'statStale');

        // Monthly Activity Visual Chart
        const monthlyChart = qs('#monthlyChart');
        if (monthlyChart) {
          const sortedMonths = Object.keys(monthlyStats).sort().reverse().slice(0, 6).reverse();
          const maxTasks = Math.max(...sortedMonths.map(m => monthlyStats[m] || 0), 1);
          const maxKyc = Math.max(...sortedMonths.map(m => kycMonthly[m] || 0), 1);
          const maxVal = Math.max(maxTasks, maxKyc);
          
          const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
          monthlyChart.innerHTML = sortedMonths.map(month => {
            const [year, m] = month.split('-');
            const shortMonth = monthNames[parseInt(m) - 1];
            const tasks = monthlyStats[month] || 0;
            const kyc = kycMonthly[month] || 0;
            const taskHeight = maxVal > 0 ? (tasks / maxVal * 80) : 0;
            const kycHeight = maxVal > 0 ? (kyc / maxVal * 80) : 0;
            return `<div class="month-bar-group">
              <div class="month-bars">
                <div class="month-bar tasks" style="height:${taskHeight}px">
                  ${tasks > 0 ? `<span class="month-bar-value">${tasks}</span>` : ''}
                </div>
                <div class="month-bar kyc" style="height:${kycHeight}px">
                  ${kyc > 0 ? `<span class="month-bar-value">${kyc}</span>` : ''}
                </div>
              </div>
              <div class="month-bar-label">${shortMonth}</div>
            </div>`;
          }).join('');
        }

        // Broker Activity Visual Chart - Horizontal Bars like Status Distribution
        const brokerChart = qs('#brokerChart');
        if (brokerChart) {
          const sortedBrokers = Object.entries(brokerStats)
            .filter(([name]) => name && name !== '(none)' && name.trim() !== '')
            .sort((a, b) => (b[1].active + b[1].completed) - (a[1].active + a[1].completed));
          // Find max for scaling (active + completed combined)
          const maxTasks = Math.max(...sortedBrokers.map(([,s]) => s.active + s.completed), 1);
          
          brokerChart.innerHTML = sortedBrokers.map(([name, stats]) => {
            const activeWidth = maxTasks > 0 ? (stats.active / maxTasks * 100) : 0;
            const completedWidth = maxTasks > 0 ? (stats.completed / maxTasks * 100) : 0;
            return `<div class="broker-row">
              <span class="broker-name" title="${escapeHtml(name)}">${escapeHtml(name)}</span>
              <div class="broker-bar-track">
                <div class="broker-bar-fill active" style="width:${activeWidth}%">${stats.active > 0 ? `<span class="bar-num">${stats.active}</span>` : ''}</div>
                <div class="broker-bar-fill completed" style="width:${completedWidth}%">${stats.completed > 0 ? `<span class="bar-num">${stats.completed}</span>` : ''}</div>
              </div>
            </div>`;
          }).join('');
        }
      });
    } catch (e) {
      console.error('Error loading statistics:', e);
    }
  }

  // Helper to parse various date formats including Excel serial numbers
  function parseDate(dateVal) {
    if (!dateVal) return null;
    
    // Check if it's an Excel serial number (numeric value)
    // Excel dates are days since Jan 1, 1900 (with a bug for 1900 leap year)
    if (typeof dateVal === 'number' && dateVal > 1 && dateVal < 100000) {
      // Excel serial date: days since Dec 30, 1899 (accounting for Excel's leap year bug)
      const excelEpoch = new Date(1899, 11, 30); // Dec 30, 1899
      const result = new Date(excelEpoch.getTime() + dateVal * 24 * 60 * 60 * 1000);
      if (!isNaN(result.getTime()) && result.getFullYear() > 1970) {
        return result;
      }
    }
    
    // Try as string
    const dateStr = String(dateVal);
    
    // Try ISO format first
    let d = new Date(dateStr);
    if (!isNaN(d.getTime()) && d.getFullYear() > 1970) return d;
    
    // Try d-MMM-yyyy format (e.g., "15-Nov-2025")
    const match = dateStr.match(/(\d{1,2})[-\s]([A-Za-z]{3})[-\s](\d{2,4})/);
    if (match) {
      const months = {jan:0,feb:1,mar:2,apr:3,may:4,jun:5,jul:6,aug:7,sep:8,oct:9,nov:10,dec:11};
      const day = parseInt(match[1]);
      const month = months[match[2].toLowerCase()];
      let year = parseInt(match[3]);
      if (year < 100) year += 2000;
      if (month !== undefined) {
        return new Date(year, month, day);
      }
    }
    return null;
  }

  // Search functionality
  const searchInput = qs('#searchInput');
  const searchInputWrap = qs('#searchInputWrap');
  const searchBtn = qs('#searchBtn');
  const searchResults = qs('#searchResults');
  const searchHint = qs('#searchHint');
  const searchTabs = qsa('.search-tab');
  let currentSearchMode = 'active'; // Default to active tasks

  // Update search UI based on mode
  const loadRowHint = qs('#loadRowHint');
  
  function updateSearchUI() {
    if (!searchHint || !searchInput || !searchInputWrap) return;
    
    if (currentSearchMode === 'active') {
      searchInputWrap.style.display = 'none'; // No input needed
      if (loadRowHint) loadRowHint.style.display = 'none';
      searchHint.textContent = 'üí° Showing tasks with status: To Do or In Progress';
    } else if (currentSearchMode === 'company') {
      searchInputWrap.style.display = 'flex';
      if (loadRowHint) loadRowHint.style.display = 'flex';
      searchInput.placeholder = 'Type company name...';
      searchInput.type = 'text';
      searchHint.textContent = '';
    }
  }

  // Search tab switching
  searchTabs.forEach(tab => {
    tab.addEventListener('click', async () => {
      searchTabs.forEach(t => t.classList.remove('active'));
      tab.classList.add('active');
      currentSearchMode = tab.getAttribute('data-search');
      if (searchInput) {
        searchInput.value = '';
      }
      updateSearchUI();
      
      // Auto-load active tasks when that tab is selected
      if (currentSearchMode === 'active') {
        await performSearch();
      } else {
        // Clear results for other modes until user searches
        if (searchResults) {
          searchResults.classList.remove('visible');
          searchResults.innerHTML = '';
        }
      }
    });
  });

  // Search button click
  if (searchBtn) {
    searchBtn.addEventListener('click', async () => {
      await performSearch();
    });
  }

  // Enter key in search input
  if (searchInput) {
    searchInput.addEventListener('keypress', async (e) => {
      if (e.key === 'Enter') {
        hideAutocomplete();
        await performSearch();
      }
    });
  }

  // Autocomplete for company search
  const autocompleteDropdown = qs('#autocompleteDropdown');
  let companyList = []; // Cache of all companies with row numbers
  let autocompleteTimeout = null;

  // Load all companies for autocomplete (includes ALL rows, not just unique companies)
  async function loadCompanyList() {
    if (companyList.length > 0) return; // Already loaded
    try {
      await Excel.run(async (context) => {
        const sheet = context.workbook.worksheets.getItemOrNullObject('TASK MANAGER FORM');
        sheet.load('name');
        await context.sync();
        if (sheet.isNullObject) return;

        // Load columns A (company) and B (task category) to differentiate multiple rows
        const dataRange = sheet.getRange('A2:B5000');
        dataRange.load('values');
        await context.sync();

        const values = dataRange.values || [];
        companyList = [];
        for (let i = 0; i < values.length; i++) {
          const name = values[i][0] ? String(values[i][0]).trim() : '';
          const category = values[i][1] ? String(values[i][1]).trim() : '';
          if (name) {
            companyList.push({ name, category, rowNum: i + 2 });
          }
        }
        // Keep ALL entries - don't remove duplicates so users can see all tasks for a company
        console.log('Loaded', companyList.length, 'company rows for autocomplete');
      });
    } catch (e) {
      console.error('Failed to load company list:', e);
    }
  }

  function showAutocomplete(query) {
    if (!autocompleteDropdown || !query || currentSearchMode !== 'company') {
      hideAutocomplete();
      return;
    }
    const q = query.toLowerCase();
    
    // Filter matches and sort: companies starting with query first, then contains
    const allMatches = companyList.filter(c => c.name.toLowerCase().includes(q));
    const startsWithMatches = allMatches.filter(c => c.name.toLowerCase().startsWith(q));
    const containsMatches = allMatches.filter(c => !c.name.toLowerCase().startsWith(q));
    const sortedMatches = [...startsWithMatches, ...containsMatches].slice(0, 15);
    
    if (sortedMatches.length === 0) {
      hideAutocomplete();
      return;
    }
    autocompleteDropdown.innerHTML = sortedMatches.map(c => {
      const categoryHint = c.category ? ` ¬∑ ${escapeHtml(c.category)}` : '';
      return `<div class="autocomplete-item" data-row="${c.rowNum}" data-name="${escapeHtml(c.name)}">
        <span class="company-name">${escapeHtml(c.name)}</span>
        <span class="row-hint">Row ${c.rowNum}${categoryHint}</span>
      </div>`;
    }).join('');
    autocompleteDropdown.classList.add('visible');

    // Wire click handlers
    autocompleteDropdown.querySelectorAll('.autocomplete-item').forEach(item => {
      item.addEventListener('click', async () => {
        const rowNum = parseInt(item.getAttribute('data-row'), 10);
        const name = item.getAttribute('data-name');
        if (searchInput) searchInput.value = name;
        hideAutocomplete();
        await selectAndLoadRow(rowNum);
      });
    });
  }

  function hideAutocomplete() {
    if (autocompleteDropdown) {
      autocompleteDropdown.classList.remove('visible');
      autocompleteDropdown.innerHTML = '';
    }
  }

  // Wire autocomplete on input
  if (searchInput) {
    searchInput.addEventListener('input', (e) => {
      if (currentSearchMode !== 'company') return;
      clearTimeout(autocompleteTimeout);
      const val = e.target.value.trim();
      if (val.length < 1) {
        hideAutocomplete();
        return;
      }
      // Debounce to avoid too many updates
      autocompleteTimeout = setTimeout(() => {
        showAutocomplete(val);
      }, 150);
    });

    searchInput.addEventListener('focus', async () => {
      if (currentSearchMode === 'company') {
        await loadCompanyList();
        if (searchInput.value.trim().length >= 1) {
          showAutocomplete(searchInput.value.trim());
        }
      }
    });

    searchInput.addEventListener('blur', () => {
      // Delay hide to allow click on dropdown
      setTimeout(hideAutocomplete, 200);
    });
  }

  // Initialize search UI on load
  updateSearchUI();

  async function performSearch() {
    if (!searchResults) return;
    
    searchResults.innerHTML = '<div class="no-results">Searching...</div>';
    searchResults.classList.add('visible');
    console.log('Search started, mode:', currentSearchMode);

    try {
      await Excel.run(async (context) => {
        const sheet = context.workbook.worksheets.getItemOrNullObject('TASK MANAGER FORM');
        sheet.load('name');
        await context.sync();
        console.log('Sheet found:', !sheet.isNullObject);
        if (sheet.isNullObject) {
          searchResults.innerHTML = '<div class="no-results">Sheet not found</div>';
          return;
        }

        // Read a fixed block of rows to avoid issues with usedRange returning too small an area.
        const maxRows = 5000;
        const dataRange = sheet.getRange(`A1:K${maxRows}`);
        dataRange.load('values');
        await context.sync();

        const rawValues = dataRange.values || [];
        console.log('Raw rows loaded (including header and blanks):', rawValues.length);

        const values = Array.isArray(rawValues) ? rawValues : [];
        const results = [];
        let scannedRows = 0;

        for (let i = 1; i < values.length; i++) { // Skip header row
          const row = values[i] || [];
          const isEmpty = row.every(c => c === null || c === '');
          if (isEmpty) continue;
          scannedRows++;
          const companyName = row[0] ? String(row[0]).trim() : '';
          const taskCategory = row[1] ? String(row[1]).trim() : '';
          const taskSummary = row[7] ? String(row[7]).trim() : ''; // Column H

          // Determine status and dates from Column H
          let hasActiveTasks = false;
          let dominantStatus = 'unknown';
          let hasTodo = false, hasProgress = false, hasDone = false;
          let todoDates = [];
          let progressDates = [];
          let doneDates = [];

          if (taskSummary) {
            const lines = taskSummary.split(/\r?\n/).filter(Boolean);
            lines.forEach(line => {
              const parsed = parseTaskLine(line);
              if (!parsed) return;
              const st = (parsed.status || '').toLowerCase();
              if (st === 'to do') {
                hasTodo = true;
                if (parsed.initiated) todoDates.push(parsed.initiated);
              } else if (st === 'in progress') {
                hasProgress = true;
                if (parsed.updated) progressDates.push(parsed.updated);
              } else if (st === 'done') {
                hasDone = true;
                if (parsed.completed) doneDates.push(parsed.completed);
              }
            });
            hasActiveTasks = hasTodo || hasProgress;
            if (hasProgress) dominantStatus = 'progress';
            else if (hasTodo) dominantStatus = 'todo';
            else if (hasDone) dominantStatus = 'done';
          }

          // Choose a status-specific date to display
          function mostRecentDate(dateArr) {
            if (!dateArr || dateArr.length === 0) return '';
            let best = null;
            dateArr.forEach(dStr => {
              if (!dStr) return;
              const d = new Date(dStr);
              if (isNaN(d.getTime())) return;
              if (!best || d > best) best = d;
            });
            if (!best) return '';
            const yyyy = best.getFullYear();
            const mm = String(best.getMonth() + 1).padStart(2,'0');
            const dd = String(best.getDate()).padStart(2,'0');
            return `${yyyy}-${mm}-${dd}`; // normalized for display formatter
          }

          let statusDateLabel = '';
          let statusDateRaw = '';
          if (dominantStatus === 'progress') {
            statusDateRaw = mostRecentDate(progressDates);
            statusDateLabel = statusDateRaw ? 'Updated' : '';
          } else if (dominantStatus === 'todo') {
            statusDateRaw = mostRecentDate(todoDates);
            statusDateLabel = statusDateRaw ? 'Initiated' : '';
          } else if (dominantStatus === 'done') {
            statusDateRaw = mostRecentDate(doneDates);
            statusDateLabel = statusDateRaw ? 'Completed' : '';
          }

          const statusDateDisplay = statusDateRaw ? formatDateForDisplay(statusDateRaw) : '';

          const rowNum = i + 1; // 1-based row number

          if (currentSearchMode === 'company') {
            const query = (searchInput ? searchInput.value : '').toLowerCase().trim();
            console.log('Checking row', rowNum, '- Company:', companyName, '- Query:', query);
            if (query && companyName.toLowerCase().includes(query)) {
              console.log('Match found:', companyName);
              results.push({ rowNum, companyName, taskCategory, dominantStatus, hasActiveTasks, statusDateLabel, statusDateDisplay });
            }
          } else if (currentSearchMode === 'active') {
            console.log('Checking row', rowNum, '- Company:', companyName, '- Active:', hasActiveTasks);
            if (hasActiveTasks) {
              results.push({ rowNum, companyName, taskCategory, dominantStatus, hasActiveTasks, statusDateLabel, statusDateDisplay });
            }
          }
        }

        const totalRows = scannedRows;
        const modeLabel = currentSearchMode === 'company' ? 'Company' : 'Active tasks';
        const rawQuery = (searchInput ? searchInput.value : '').trim();
        console.log('Search complete, mode:', modeLabel, 'rows scanned:', totalRows, 'matches:', results.length, 'query:', rawQuery);
        if (results.length === 0) {
          searchResults.innerHTML = '<div class="no-results">No results found</div>';
        } else {
          searchResults.innerHTML = results.map(r => {
            const statusBadge = r.dominantStatus === 'progress' 
              ? '<span class="status-badge progress">In Progress</span>'
              : r.dominantStatus === 'todo'
              ? '<span class="status-badge todo">To Do</span>'
              : r.dominantStatus === 'done'
              ? '<span class="status-badge done">Done</span>'
              : '';

            const datePart = (r.statusDateLabel && r.statusDateDisplay)
              ? ` ¬∑ ${r.statusDateLabel} ${escapeHtml(r.statusDateDisplay)}`
              : '';

            return `<div class="search-result-item" data-row="${r.rowNum}">
              <div class="company">${escapeHtml(r.companyName || '(No name)')}${statusBadge}</div>
              <div class="meta">Row ${r.rowNum} ¬∑ ${escapeHtml(r.taskCategory || 'No category')}${datePart}</div>
            </div>`;
          }).join('');

          // Wire click handlers
          searchResults.querySelectorAll('.search-result-item').forEach(item => {
            item.addEventListener('click', async () => {
              const rowNum = parseInt(item.getAttribute('data-row'), 10);
              await selectAndLoadRow(rowNum);
              searchResults.classList.remove('visible');
            });
          });
        }
      });
    } catch (e) {
      console.error('Search error:', e);
      searchResults.innerHTML = '<div class="no-results">Search error</div>';
    }
  }

  async function selectAndLoadRow(rowNum) {
    await Excel.run(async (context) => {
      const sheet = context.workbook.worksheets.getItemOrNullObject('TASK MANAGER FORM');
      sheet.load('name');
      await context.sync();
      if (sheet.isNullObject) return;

      const targetRange = sheet.getRange(`A${rowNum}`);
      targetRange.select();
      await context.sync();
    });
    await loadFromActiveRow();
  }

  // Find Last KYC Produced date for a company
  async function findLastKycDate(companyName) {
    if (!companyName) return null;
    
    return Excel.run(async (context) => {
      const sheet = context.workbook.worksheets.getItemOrNullObject('TASK MANAGER FORM');
      sheet.load('name');
      await context.sync();
      if (sheet.isNullObject) return null;

      const usedRange = sheet.getUsedRange();
      usedRange.load('values');
      await context.sync();

      const values = usedRange.values || [];
      let lastKycDate = null;

      for (let i = 1; i < values.length; i++) {
        const row = values[i];
        const rowCompany = row[0] ? String(row[0]).trim().toLowerCase() : '';
        const taskSummary = row[7] ? String(row[7]).trim() : ''; // Column H

        if (rowCompany === companyName.toLowerCase() && taskSummary) {
          // Look for KYC task with Done status
          const lines = taskSummary.split(/\r?\n/).filter(Boolean);
          lines.forEach(line => {
            const lower = line.toLowerCase();
            if ((lower.includes('kyc') && lower.includes(': done'))) {
              // Try to extract completed date
              const completedMatch = line.match(/completed:\s*(\d{1,2}[-\s][A-Za-z]{3}[-\s]\d{2,4})/i);
              if (completedMatch) {
                lastKycDate = completedMatch[1];
              }
            }
          });
        }
      }
      return lastKycDate;
    });
  }

  // Format date as d-MMM-yyyy (e.g., 1-Jul-2025)
  function formatDateForDisplay(dateStr) {
    if (!dateStr) return '';
    const d = new Date(dateStr);
    if (isNaN(d.getTime())) return '';
    const months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
    const day = d.getDate();
    const month = months[d.getMonth()];
    const year = d.getFullYear();
    return `${day}-${month}-${year}`;
  }
  
  // Alias for Excel output (same format)
  const formatDateForExcel = formatDateForDisplay;

  // Get selected task categories
  function getSelectedCategories() {
    return qsa('#taskCategories .category-toggle:checked').map(cb => cb.value);
  }

  // Check if "Other Task" is selected
  function isOtherTaskSelected() {
    const cb = qs('#taskCategories .category-toggle[value="Other Task"]');
    return cb && cb.checked;
  }

  function getTaskCard(taskName){
    // __other__ card is now outside #taskCards
    if (taskName === '__other__') {
      return qs('#otherTaskCard');
    }
    return taskCardsContainer ? taskCardsContainer.querySelector(`.task-card[data-task="${taskName}"]`) : null;
  }

  function getTaskStatusChips(card){
    if (!card) return [];
    const container = card.querySelector('[data-role="status-chips"]');
    return container ? Array.from(container.querySelectorAll('.chip')) : [];
  }

  function setCardStatus(card, val){
    const chips = getTaskStatusChips(card);
    chips.forEach(c=>{
      c.classList.toggle('active', c.getAttribute('data-value')===val);
    });
  }

  function getCardStatus(card){
    const chips = getTaskStatusChips(card);
    const active = chips.find(c=>c.classList.contains('active'));
    return active ? active.getAttribute('data-value') : 'To Do';
  }

  function wireCardChips(){
    // Wire chips in #taskCards and #otherTaskCard
    qsa('#taskCards [data-role="status-chips"] .chip, #otherTaskCard [data-role="status-chips"] .chip').forEach(chip => {
      chip.addEventListener('click', () => {
        const container = chip.closest('[data-role="status-chips"]');
        if (!container) return;
        const siblings = Array.from(container.querySelectorAll('.chip'));
        siblings.forEach(c=>{
          c.classList.toggle('active', c === chip);
        });
      });
    });
  }

  function syncTasksVisibility(){
    if (!tasksRowEl || !taskCardsContainer) return;
    const isOther = isOtherTaskSelected();
    const otherCard = qs('#otherTaskCard'); // Now outside #taskCards
    const selectedCategories = getSelectedCategories();
    const hasNonOtherCategory = selectedCategories.some(c => c !== 'Other Task');

    // Show tasks section if any non-"Other Task" category is selected
    if (hasNonOtherCategory) {
      tasksRowEl.style.display = '';
    } else {
      tasksRowEl.style.display = 'none';
    }

    // Show/hide fixed task cards based on task toggles
    const selected = new Set(getSelectedTaskToggles());
    const fixedCards = qsa('#taskCards .task-card');
    fixedCards.forEach(card => {
      const name = card.getAttribute('data-task');
      card.style.display = selected.has(name) ? '' : 'none';
    });

    // Show __other__ card if "Other Task" category is selected
    if (otherCard) {
      otherCard.style.display = isOther ? '' : 'none';
    }
  }

  // Update Extra Note placeholder based on selected categories
  function updateExtraNotePlaceholder() {
    if (!extraNoteEl) return;
    const categories = getSelectedCategories().filter(c => c !== 'Other Task');
    if (categories.length === 0) {
      extraNoteEl.placeholder = 'General note about this task';
    } else if (categories.length === 1) {
      extraNoteEl.placeholder = 'General note about this ' + categories[0];
    } else {
      extraNoteEl.placeholder = 'General note about these tasks';
    }
  }

  // Wire category checkboxes to update visibility and placeholder
  qsa('#taskCategories .category-toggle').forEach(cb => {
    cb.addEventListener('change', () => {
      syncTasksVisibility();
      updateExtraNotePlaceholder();
    });
  });

  function getSelectedTaskToggles(){
    return qsa('#tasksChecklist .task-toggle:checked').map(cb => cb.value);
  }

  // Reorder checkboxes so checked ones appear at the top
  function reorderCheckboxesToTop(containerSelector) {
    const container = qs(containerSelector);
    if (!container) return;
    
    // Get all items - could be direct children (div wrappers) or labels
    const items = Array.from(container.children);
    if (items.length === 0) return;
    
    // Sort: checked items first, then unchecked (maintain original order within each group)
    const checked = [];
    const unchecked = [];
    items.forEach(item => {
      const cb = item.querySelector('input[type=checkbox]') || item.querySelector('input[type="checkbox"]');
      if (cb && cb.checked) {
        checked.push(item);
      } else {
        unchecked.push(item);
      }
    });
    
    // Re-append in sorted order: checked first, then unchecked
    [...checked, ...unchecked].forEach(item => container.appendChild(item));
  }

  async function loadTeamMembers(){
    if (teamMembersLoaded) return;
    teamMembersLoaded = true; // guard immediately to avoid overlapping calls
    const box = qs('#assignees');
    if (!box) return;
    // Additional DOM-level guard in case the script is evaluated more than once
    if (box.dataset.initialized === '1') {
      return;
    }
    box.dataset.initialized = '1';
    box.innerHTML='';

    await Excel.run(async (context) => {
      const sheet = context.workbook.worksheets.getItemOrNullObject('Team members');
      sheet.load('name');
      await context.sync();
      if (sheet.isNullObject) {
        console.error('Team members sheet not found');
        return;
      }

      // Read column A only for team member names
      const usedRange = sheet.getUsedRange();
      usedRange.load('values');
      await context.sync();

      const values = usedRange.values || [];
      const namesRaw = values.slice(1) // skip header row
        .map(row => row[0])
        .filter(n => n && String(n).trim().length > 0)
        .map(n => String(n).trim());

      const names = Array.from(new Set(namesRaw)); // dedupe
      console.log('Team members loaded from column A:', names); // Debug log

      names.forEach(n => {
        const w = document.createElement('div');
        w.innerHTML = `<label><input type="checkbox" value="${n}"> ${n}</label>`;
        box.appendChild(w);
      });

      if (brokerLeadEl) {
        brokerLeadEl.innerHTML = '';
        const noneOpt = document.createElement('option');
        noneOpt.value = '';
        noneOpt.textContent = '(none)';
        brokerLeadEl.appendChild(noneOpt);
        names.forEach(n => {
          const opt = document.createElement('option');
          opt.value = n;
          opt.textContent = n;
          brokerLeadEl.appendChild(opt);
        });
      }
    });
  }

  function getSelectedAssignees(){
    return Array.from(document.querySelectorAll('#assignees input[type=checkbox]:checked')).map(i=>i.value);
  }

  // Populate per-task assignee dropdowns with selected assignees
  function updateTaskAssigneeDropdowns() {
    const selectedAssignees = getSelectedAssignees();
    const dropdowns = qsa('.task-assignee-select');
    
    dropdowns.forEach(dropdown => {
      const currentValue = dropdown.value;
      dropdown.innerHTML = '';
      
      // Add empty option
      const emptyOpt = document.createElement('option');
      emptyOpt.value = '';
      emptyOpt.textContent = '(Select assignee)';
      dropdown.appendChild(emptyOpt);
      
      // Add selected assignees as options
      selectedAssignees.forEach(name => {
        const opt = document.createElement('option');
        opt.value = name;
        opt.textContent = name;
        dropdown.appendChild(opt);
      });
      
      // Auto-select if only one assignee
      if (selectedAssignees.length === 1) {
        dropdown.value = selectedAssignees[0];
      } else if (selectedAssignees.includes(currentValue)) {
        // Restore previous selection if still valid
        dropdown.value = currentValue;
      }
    });
  }

  // Wire assignee checkboxes to update per-task dropdowns
  document.querySelectorAll('#assignees').forEach(container => {
    container.addEventListener('change', (e) => {
      if (e.target.type === 'checkbox') {
        updateTaskAssigneeDropdowns();
      }
    });
  });

  async function getActiveRowIndex(){
    return Excel.run(async (context) => {
      // Use the currently selected range in the workbook
      const range = context.workbook.getSelectedRange();
      range.load('rowIndex');
      await context.sync();
      // rowIndex is 0-based; UI shows 1-based row numbers
      return range.rowIndex + 1;
    });
  }

  function parseTaskLine(raw){
    // More flexible parsing that handles fields in any order
    if (!raw) return null;
    
    // First, check basic structure: "TaskName: Status || Assigned to ..."
    const basicMatch = /^(.*?)\s*:\s*(to do|in progress|done)\s*\|\|\s*assigned to\s+([^|]+)/i.exec(raw);
    if (!basicMatch) return null;
    
    const result = {
      name: basicMatch[1].trim(),
      status: basicMatch[2],
      assignee: basicMatch[3].trim(),
      comment: '',
      giveUpId: '',
      initiated: '',
      updated: '',
      completed: '',
      deadline: ''
    };
    
    // Extract optional fields in any order
    const commentMatch = /\|\|\s*comment:\s*([^|]+)/i.exec(raw);
    if (commentMatch) result.comment = commentMatch[1].trim();
    
    const giveUpMatch = /\|\|\s*give-up id:\s*([^|]+)/i.exec(raw);
    if (giveUpMatch) result.giveUpId = giveUpMatch[1].trim();
    
    const initiatedMatch = /\|\|\s*task initiated:\s*([^|]+)/i.exec(raw);
    if (initiatedMatch) result.initiated = initiatedMatch[1].trim();
    
    const updatedMatch = /\|\|\s*status updated:\s*([^|]+)/i.exec(raw);
    if (updatedMatch) result.updated = updatedMatch[1].trim();
    
    const completedMatch = /\|\|\s*completed:\s*([^|]+)/i.exec(raw);
    if (completedMatch) result.completed = completedMatch[1].trim();
    
    const deadlineMatch = /\|\|\s*deadline:\s*([^|]+)/i.exec(raw);
    if (deadlineMatch) result.deadline = deadlineMatch[1].trim();
    
    return result;
  }

  function buildSummaryLine(v){
    const parts = [];
    const status = v.status || 'To Do';
    // First segment must match parseTaskLine: "<TaskName>: <Status>"
    parts.push(`${v.name}: ${status}`);
    parts.push(`Assigned to ${v.assignees}`);
    if (v.comment) parts.push(`Comment: ${v.comment}`);
    if (v.giveUpId) parts.push(`Give-up ID: ${v.giveUpId}`);
    // Only one date field will be set based on status (last action)
    if (v.initiated) parts.push(`Task initiated: ${v.initiated}`);
    if (v.updated) parts.push(`Status updated: ${v.updated}`);
    if (v.completed) parts.push(`Completed: ${v.completed}`);
    if (v.deadline) parts.push(`Deadline: ${v.deadline}`);
    return parts.join(' || ');
  }

  async function loadFromActiveRow(){
    await loadTeamMembers();
    await Excel.run(async (context) => {
      // Get active row within the same context to avoid sync issues
      const selectedRange = context.workbook.getSelectedRange();
      selectedRange.load('rowIndex');
      await context.sync();
      const uiRow = selectedRange.rowIndex + 1;

      const sheet = context.workbook.worksheets.getItemOrNullObject('TASK MANAGER FORM');
      sheet.load('name');
      await context.sync();
      if (sheet.isNullObject) return;

      // Load row-level metadata and Column H, J, K in one go
      const companyRange = sheet.getRange(`A${uiRow}`);
      const descRange = sheet.getRange(`B${uiRow}`);
      const assigneesRange = sheet.getRange(`C${uiRow}`);
      const brokerRange = sheet.getRange(`D${uiRow}`);
      const datesRange = sheet.getRange(`E${uiRow}:G${uiRow}`);
      const hRange = sheet.getRange(`H${uiRow}`);
      const jRange = sheet.getRange(`J${uiRow}`);
      const kRange = sheet.getRange(`K${uiRow}`);
      companyRange.load('values');
      descRange.load('values');
      assigneesRange.load('values');
      brokerRange.load('values');
      datesRange.load('values');
      hRange.load('values');
      jRange.load('values');
      kRange.load('values');
      await context.sync();

      // Company name from column A
      const companyVal = (companyRange.values && companyRange.values[0] && companyRange.values[0][0])
        ? String(companyRange.values[0][0])
        : '';
      if (companyNameInput) companyNameInput.value = companyVal;

      const descVal = (descRange.values && descRange.values[0] && descRange.values[0][0])
        ? String(descRange.values[0][0])
        : '';
      // Parse comma-separated categories and check the corresponding checkboxes
      const categories = descVal.split(',').map(s => s.trim()).filter(Boolean);
      const allowedDescs = ['Onboarding', 'Amended Product/Rate', 'KYC update', 'Other Task'];
      qsa('#taskCategories .category-toggle').forEach(cb => {
        const match = categories.some(cat => cat.toLowerCase() === cb.value.toLowerCase());
        cb.checked = match;
      });

      const brokerVal = (brokerRange.values && brokerRange.values[0] && brokerRange.values[0][0])
        ? String(brokerRange.values[0][0])
        : '';

      if (brokerLeadEl) {
        brokerLeadEl.value = brokerVal;
      }

      // Assignees from column C
      const assigneesVal = (assigneesRange.values && assigneesRange.values[0] && assigneesRange.values[0][0])
        ? String(assigneesRange.values[0][0])
        : '';
      const assigneesList = assigneesVal.split(/[,;]+/).map(s => s.trim().toLowerCase()).filter(Boolean);
      console.log('Assignees from column C:', assigneesList);
      document.querySelectorAll('#assignees input[type=checkbox]').forEach(cb => {
        cb.checked = assigneesList.includes(cb.value.toLowerCase());
      });

      const datesRow = (datesRange.values && datesRange.values[0]) ? datesRange.values[0] : [null, null, null];

      function toInputDate(v){
        if (v == null || v === '') return '';
        
        // Excel serial number (days since 1900-01-01, with Excel's leap year bug)
        if (typeof v === 'number') {
          // Excel serial date: 1 = Jan 1, 1900
          const excelEpoch = new Date(1899, 11, 30); // Dec 30, 1899 (Excel's day 0)
          const d = new Date(excelEpoch.getTime() + v * 86400000);
          const yyyy = d.getFullYear();
          const mm = String(d.getMonth() + 1).padStart(2,'0');
          const dd = String(d.getDate()).padStart(2,'0');
          return `${yyyy}-${mm}-${dd}`;
        }
        
        // Excel usually returns Date objects for date cells
        if (v instanceof Date) {
          const yyyy = v.getFullYear();
          const mm = String(v.getMonth() + 1).padStart(2,'0');
          const dd = String(v.getDate()).padStart(2,'0');
          return `${yyyy}-${mm}-${dd}`;
        }
        
        // Handle d-MMM-yyyy format (e.g., "1-Jul-2025")
        const s = String(v).trim();
        const dmmyMatch = s.match(/^(\d{1,2})-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d{4})$/i);
        if (dmmyMatch) {
          const months = {jan:0,feb:1,mar:2,apr:3,may:4,jun:5,jul:6,aug:7,sep:8,oct:9,nov:10,dec:11};
          const day = parseInt(dmmyMatch[1], 10);
          const mon = months[dmmyMatch[2].toLowerCase()];
          const year = parseInt(dmmyMatch[3], 10);
          const dd = String(day).padStart(2,'0');
          const mm = String(mon + 1).padStart(2,'0');
          return `${year}-${mm}-${dd}`;
        }
        
        // Try to parse strings / other values as dates
        const d = new Date(v);
        if (!isNaN(d.getTime())) {
          const yyyy = d.getFullYear();
          const mm = String(d.getMonth() + 1).padStart(2,'0');
          const dd = String(d.getDate()).padStart(2,'0');
          return `${yyyy}-${mm}-${dd}`;
        }
        
        // Fallback: attempt to slice a yyyy-MM-dd looking prefix
        return s.length >= 10 ? s.slice(0,10) : '';
      }

      console.log('Date values from Excel:', datesRow); // Debug log
      if (initialRequestInput) initialRequestInput.value = toInputDate(datesRow[0]);
      if (introEmailInput) introEmailInput.value = toInputDate(datesRow[1]);
      if (remindersStartInput) remindersStartInput.value = toInputDate(datesRow[2]);
      console.log('Parsed dates:', initialRequestInput?.value, introEmailInput?.value, remindersStartInput?.value); // Debug log

      // Email Frequency from column J
      const freqVal = (jRange.values && jRange.values[0] && jRange.values[0][0])
        ? String(jRange.values[0][0])
        : '';
      if (emailFrequencyEl) emailFrequencyEl.value = freqVal;

      // Extra Note from column K
      const noteVal = (kRange.values && kRange.values[0] && kRange.values[0][0])
        ? String(kRange.values[0][0])
        : '';
      if (extraNoteEl) extraNoteEl.value = noteVal;

      const summary = (hRange.values && hRange.values[0] && hRange.values[0][0])
        ? String(hRange.values[0][0])
        : '';

      // Parse all task lines in H
      const lines = summary
        .split(/\r?\n/)
        .map(s => s.trim())
        .filter(Boolean);
      const parsedTasks = [];
      const nonTaskLines = [];
      for (let i = 0; i < lines.length; i++) {
        const cand = parseTaskLine(lines[i]);
        if (cand) {
          parsedTasks.push(cand);
        } else {
          nonTaskLines.push(lines[i]);
        }
      }

      // Sort tasks by status priority: To Do > In Progress > Done
      const statusPriority = { 'to do': 1, 'in progress': 2, 'done': 3 };
      parsedTasks.sort((a, b) => {
        const aPriority = statusPriority[(a.status || '').toLowerCase()] || 4;
        const bPriority = statusPriority[(b.status || '').toLowerCase()] || 4;
        return aPriority - bPriority;
      });

      // Note: Assignees are already loaded from Column C (lines 1297-1305)
      // Column C contains ALL assignees including "passive" ones not assigned to specific tasks
      // We don't overwrite here - the checkboxes are already correctly set from Column C
      console.log('Parsed tasks:', parsedTasks); // Debug log

      // Update per-task assignee dropdowns with selected assignees
      updateTaskAssigneeDropdowns();

      // Reset all cards and task selections
      qsa('#tasksChecklist .task-toggle').forEach(cb => { cb.checked = false; });
      qsa('#taskCards .task-card, #otherTaskCard').forEach(card => {
        const statusChips = getTaskStatusChips(card);
        statusChips.forEach(c => c.classList.remove('active'));
        const commentEl = card.querySelector('[data-role="comment"]');
        const deadlineEl = card.querySelector('[data-role="deadline"]');
        const giveUpIdEl = card.querySelector('[data-role="giveUpId"]');
        const taskAssigneeEl = card.querySelector('[data-role="task-assignee"]');
        if (commentEl) commentEl.value = '';
        if (deadlineEl) deadlineEl.value = '';
        if (giveUpIdEl) giveUpIdEl.value = '';
        if (taskAssigneeEl) taskAssigneeEl.value = '';
      });

      const isOther = isOtherTaskSelected();
      if (isOther) {
        // Use __other__ card with first parsed task if present
        const otherCard = getTaskCard('__other__');
        if (otherCard) {
          const t = parsedTasks[0] || null;
          if (taskNameInput) taskNameInput.value = t && t.name ? t.name : '';
          if (t) {
            const sNorm = (t.status || '').toLowerCase();
            const displayStatus = sNorm === 'in progress' ? 'In Progress'
              : sNorm === 'done' ? 'Done'
              : 'To Do';
            setCardStatus(otherCard, displayStatus);
            const commentEl = otherCard.querySelector('[data-role="comment"]');
            const deadlineEl = otherCard.querySelector('[data-role="deadline"]');
            const taskAssigneeEl = otherCard.querySelector('[data-role="task-assignee"]');
            if (commentEl) commentEl.value = t.comment || '';
            if (deadlineEl) deadlineEl.value = (t.deadline || '').slice(0,10);
            // Set per-task assignee from parsed task
            if (taskAssigneeEl && t.assignee) {
              taskAssigneeEl.value = t.assignee.trim();
            }
          }
        }
      } else {
        // Fixed tasks: tick checkboxes and populate corresponding cards
        const toggles = qsa('#tasksChecklist .task-toggle');
        toggles.forEach(cb => {
          const name = cb.value;
          // Map legacy "KYC (Internal)" to "KYC (produced by LCMC)"
          const t = parsedTasks.find(pt => {
            const ptName = (pt.name || '').toLowerCase();
            const cbName = name.toLowerCase();
            if (ptName === cbName) return true;
            // Legacy mapping
            if (cbName === 'kyc (produced by lcmc)' && ptName === 'kyc (internal)') return true;
            return false;
          });
          cb.checked = !!t;
          const card = getTaskCard(name);
          if (card && t) {
            const sNorm = (t.status || '').toLowerCase();
            const displayStatus = sNorm === 'in progress' ? 'In Progress'
              : sNorm === 'done' ? 'Done'
              : 'To Do';
            setCardStatus(card, displayStatus);
            const commentEl = card.querySelector('[data-role="comment"]');
            const deadlineEl = card.querySelector('[data-role="deadline"]');
            const giveUpIdEl = card.querySelector('[data-role="giveUpId"]');
            const taskAssigneeEl = card.querySelector('[data-role="task-assignee"]');
            if (commentEl) commentEl.value = t.comment || '';
            if (deadlineEl) deadlineEl.value = (t.deadline || '').slice(0,10);
            if (giveUpIdEl) giveUpIdEl.value = t.giveUpId || '';
            // Set per-task assignee from parsed task
            if (taskAssigneeEl && t.assignee) {
              taskAssigneeEl.value = t.assignee.trim();
            }
          }
        });
      }

      // Audit info from the most recently completed/updated task if available
      if (auditTextEl) {
        let chosenAudit = null;
        if (parsedTasks.length > 0) {
          chosenAudit = parsedTasks[0];
        }
        if (chosenAudit) {
          const parts = [];
          if (chosenAudit.initiated) parts.push(`Task initiated: ${chosenAudit.initiated}`);
          if (chosenAudit.updated) parts.push(`Status updated: ${chosenAudit.updated}`);
          if (chosenAudit.completed) parts.push(`Completed: ${chosenAudit.completed}`);
          auditTextEl.textContent = parts.join(' | ');
        } else {
          auditTextEl.textContent = '';
        }
      }

      // Update Last KYC Produced date
      const lastKycEl = qs('#lastKycDate');
      if (lastKycEl && companyVal) {
        // Look for KYC Done status in current row's tasks
        let kycCompletedDate = null;
        parsedTasks.forEach(t => {
          if (t.name && t.name.toLowerCase().includes('kyc') && 
              t.status && t.status.toLowerCase() === 'done' && t.completed) {
            kycCompletedDate = t.completed;
          }
        });
        if (kycCompletedDate) {
          lastKycEl.textContent = kycCompletedDate;
        } else {
          // Search all rows for this company's last KYC
          findLastKycDate(companyVal).then(date => {
            lastKycEl.textContent = date || '‚Äî';
          });
        }
      } else if (lastKycEl) {
        lastKycEl.textContent = '‚Äî';
      }

      syncTasksVisibility();
      updateDateDisplays();
      updateExtraNotePlaceholder();
      
      // Reorder checked items to top
      reorderCheckboxesToTop('#assignees');
      reorderCheckboxesToTop('#tasksChecklist');
      reorderCheckboxesToTop('#taskCategories');

      // Track current row number for save logic
      currentRowNum = uiRow;

      // Apply deadline warnings to task cards
      applyDeadlineWarnings();

      // Update email summary button state
      updateEmailSummaryButton();

      // Close email summary section when switching rows
      if (emailSummarySection) {
        emailSummarySection.classList.remove('visible');
      }
    });
  }

  async function saveToActiveRow(){
    const descVal = getSelectedCategories().join(', ');
    const assignees = getSelectedAssignees().join(', ');
    const isOther = isOtherTaskSelected();
    console.log('Saving - Categories:', descVal, 'Assignees:', assignees, 'IsOther:', isOther);
    await Excel.run(async (context) => {
      // Get active row within the same context to avoid sync issues
      const selectedRange = context.workbook.getSelectedRange();
      selectedRange.load('rowIndex');
      await context.sync();
      const uiRow = selectedRange.rowIndex + 1;

      const sheet = context.workbook.worksheets.getItemOrNullObject('TASK MANAGER FORM');
      sheet.load('name');
      await context.sync();
      if (sheet.isNullObject) return;

      // Persist row-level dates (E-G)
      const datesRange = sheet.getRange(`E${uiRow}:G${uiRow}`);
      datesRange.load('values');

      // Persist company name (A), task category (B), assignees (C), broker lead (D)
      const companyRange = sheet.getRange(`A${uiRow}`);
      const descRange = sheet.getRange(`B${uiRow}`);
      const assigneesRange = sheet.getRange(`C${uiRow}`);
      const brokerRange = sheet.getRange(`D${uiRow}`);

      const hRange = sheet.getRange(`H${uiRow}`);
      const jRange = sheet.getRange(`J${uiRow}`);
      const kRange = sheet.getRange(`K${uiRow}`);
      hRange.load('values');
      await context.sync();

      const datesRow = (datesRange.values && datesRange.values[0]) ? datesRange.values[0] : [null,null,null];

      // Format dates as d-MMM-yyyy for Excel display
      if (initialRequestInput) datesRow[0] = formatDateForExcel(initialRequestInput.value);
      if (introEmailInput) datesRow[1] = formatDateForExcel(introEmailInput.value);
      if (remindersStartInput) datesRow[2] = formatDateForExcel(remindersStartInput.value);

      datesRange.values = [datesRow];

      descRange.values = [[descVal]];

      if (brokerLeadEl) {
        brokerRange.values = [[brokerLeadEl.value || '']];
      }

      if (companyNameInput) {
        companyRange.values = [[companyNameInput.value || '']];
      }

      // Save assignees to Column C
      assigneesRange.values = [[assignees]];
      console.log('Saving assignees to column C:', assignees);

      // Save Email Frequency (J) and Extra Note (K)
      if (emailFrequencyEl) {
        jRange.values = [[emailFrequencyEl.value || '']];
      }
      if (extraNoteEl) {
        kRange.values = [[extraNoteEl.value || '']];
      }

      const existing = (hRange.values && hRange.values[0] && hRange.values[0][0])
        ? String(hRange.values[0][0])
        : '';

      const lines = existing
        .split(/\r?\n/)
        .map(s => s.trim())
        .filter(Boolean);

      const nonTaskLines = lines.filter(l => !parseTaskLine(l));
      const newTaskLines = [];

      // Parse existing tasks to preserve dates
      const existingTasks = {};
      lines.forEach(l => {
        const parsed = parseTaskLine(l);
        if (parsed) {
          existingTasks[parsed.name.toLowerCase()] = parsed;
        }
      });

      // Helper to get today's date in d-MMM-yyyy format
      const getTodayFormatted = () => {
        const d = new Date();
        const months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
        return `${String(d.getDate()).padStart(2,'0')} ${months[d.getMonth()]} ${String(d.getFullYear()).slice(-2)}`;
      };

      // Helper to compute dates based on status and existing task
      // Only show ONE date field based on current status (last action):
      // - To Do: Task initiated
      // - In Progress: Status updated
      // - Done: Completed
      const computeDates = (name, newStatus, existingTask) => {
        const today = getTodayFormatted();
        const oldStatus = existingTask ? (existingTask.status || '').toLowerCase() : '';
        const newStatusLower = (newStatus || '').toLowerCase();
        
        // Preserve existing dates (use empty string if not present)
        let initiated = (existingTask && existingTask.initiated) ? existingTask.initiated : '';
        let updated = (existingTask && existingTask.updated) ? existingTask.updated : '';
        let completed = (existingTask && existingTask.completed) ? existingTask.completed : '';
        
        // Check if this task has ANY date - if not, it's effectively new
        const hasAnyDate = initiated || updated || completed;

        // Update the relevant date based on status
        // We show only ONE date field based on current status (last action)
        if (newStatusLower === 'to do') {
          // For To Do: always show initiated date
          initiated = initiated || today;
          // Clear other dates for display
          updated = '';
          completed = '';
        } else if (newStatusLower === 'in progress') {
          // For In Progress: set updated date if new or status changed
          if (!hasAnyDate || oldStatus !== newStatusLower) {
            updated = today;
          }
          // Clear other dates for display
          initiated = '';
          completed = '';
        } else if (newStatusLower === 'done') {
          // For Done: set completed date if new or status changed
          if (!hasAnyDate || !completed || oldStatus !== newStatusLower) {
            completed = today;
          }
          // Clear other dates for display
          initiated = '';
          updated = '';
        }

        return { initiated, updated, completed };
      };

      if (isOther) {
        const otherCard = getTaskCard('__other__');
        const name = taskNameInput ? taskNameInput.value.trim() : '';
        if (name) {
          const status = getCardStatus(otherCard) || 'To Do';
          const commentEl = otherCard ? otherCard.querySelector('[data-role="comment"]') : null;
          const deadlineEl = otherCard ? otherCard.querySelector('[data-role="deadline"]') : null;
          const taskAssigneeEl = otherCard ? otherCard.querySelector('[data-role="task-assignee"]') : null;
          // Use per-task assignee if set, otherwise fall back to global assignees
          const taskAssignee = taskAssigneeEl && taskAssigneeEl.value ? taskAssigneeEl.value : assignees;
          
          // Look up existing task to preserve dates
          const existingTask = existingTasks[name.toLowerCase()];
          const dates = computeDates(name, status, existingTask);
          
          const payload = {
            name,
            status,
            assignees: taskAssignee,
            comment: commentEl ? commentEl.value.trim() : '',
            giveUpId: '',
            initiated: dates.initiated,
            updated: dates.updated,
            completed: dates.completed,
            deadline: deadlineEl ? deadlineEl.value : ''
          };
          const builtLine = buildSummaryLine(payload);
          newTaskLines.push({ line: builtLine, status });
        }
      } else {
        const toggles = getSelectedTaskToggles();
        const fixedNames = ['Broker Agreement','Give-up Agreement','Amend Annex A','KYC (produced by LCMC)','KYC External'];
        toggles.forEach(name => {
          if (!fixedNames.includes(name)) return;
          const card = getTaskCard(name);
          if (!card) return;
          const status = getCardStatus(card);
          const commentEl = card.querySelector('[data-role="comment"]');
          const deadlineEl = card.querySelector('[data-role="deadline"]');
          const giveUpIdEl = card.querySelector('[data-role="giveUpId"]');
          const taskAssigneeEl = card.querySelector('[data-role="task-assignee"]');
          // Use per-task assignee if set, otherwise fall back to global assignees
          const taskAssignee = taskAssigneeEl && taskAssigneeEl.value ? taskAssigneeEl.value : assignees;
          
          // Look up existing task to preserve dates (handle legacy KYC name)
          let existingTask = existingTasks[name.toLowerCase()];
          if (!existingTask && name.toLowerCase() === 'kyc (produced by lcmc)') {
            existingTask = existingTasks['kyc (internal)'];
          }
          const dates = computeDates(name, status, existingTask);
          
          const payload = {
            name,
            status,
            assignees: taskAssignee,
            comment: commentEl ? commentEl.value.trim() : '',
            giveUpId: giveUpIdEl ? giveUpIdEl.value.trim() : '',
            initiated: dates.initiated,
            updated: dates.updated,
            completed: dates.completed,
            deadline: deadlineEl ? deadlineEl.value : ''
          };
          newTaskLines.push({ line: buildSummaryLine(payload), status });
        });
      }

      // Sort task lines by status priority: To Do > In Progress > Done
      const statusPriority = { 'to do': 1, 'in progress': 2, 'done': 3 };
      newTaskLines.sort((a, b) => {
        const aPriority = statusPriority[(a.status || '').toLowerCase()] || 4;
        const bPriority = statusPriority[(b.status || '').toLowerCase()] || 4;
        return aPriority - bPriority;
      });
      const sortedLines = newTaskLines.map(t => t.line);

      const newValue = nonTaskLines.concat(sortedLines).filter(Boolean).join('\n');
      console.log('Saving to H - newTaskLines:', sortedLines, 'newValue:', newValue);

      hRange.values = [[newValue]];

      // Apply font color based on status priority: In Progress > To Do > Done
      // Since Excel.js can't do per-line colors, use the "most urgent" status
      if (sortedLines.length > 0) {
        let hasInProgress = false;
        let hasToDo = false;
        let hasDone = false;
        
        sortedLines.forEach(line => {
          const lower = line.toLowerCase();
          if (lower.includes(': in progress')) hasInProgress = true;
          else if (lower.includes(': to do')) hasToDo = true;
          else if (lower.includes(': done')) hasDone = true;
        });
        
        // Priority: In Progress (orange) > To Do (green) > Done (red)
        // Use original Google Sheet colours: To Do #34a853, In Progress #ff9900, Done #cc6666
        let fontColor;
        if (hasInProgress) {
          fontColor = '#ff9900'; // In Progress (orange)
        } else if (hasToDo) {
          fontColor = '#34a853'; // To Do (green)
        } else if (hasDone) {
          fontColor = '#cc6666'; // Done (soft red)
        } else {
          fontColor = '#34a853'; // default green
        }
        hRange.format.font.color = fontColor;
      }

      await context.sync();
      console.log('Save completed successfully for row', uiRow);
    });
  }

  // Clear form for a fresh new task entry
  function clearFormForNewTask() {
    // Clear company name
    if (companyNameInput) companyNameInput.value = '';
    
    // Reset task category checkboxes
    qsa('#taskCategories .category-toggle').forEach(cb => {
      cb.checked = false;
    });
    
    // Clear broker lead
    if (brokerLeadEl) brokerLeadEl.value = '';
    
    // Clear all assignee checkboxes
    document.querySelectorAll('#assignees input[type=checkbox]').forEach(cb => {
      cb.checked = false;
    });
    
    // Clear dates
    if (initialRequestInput) initialRequestInput.value = '';
    if (introEmailInput) introEmailInput.value = '';
    if (remindersStartInput) remindersStartInput.value = '';
    
    // Clear email frequency and extra note
    if (emailFrequencyEl) emailFrequencyEl.value = '';
    if (extraNoteEl) extraNoteEl.value = '';
    
    // Uncheck all task toggles
    qsa('#tasksChecklist .task-toggle').forEach(cb => {
      cb.checked = false;
    });
    
    // Reset all task cards (including Other Task card)
    qsa('#taskCards .task-card, #otherTaskCard').forEach(card => {
      // Reset status chips
      const chips = card.querySelectorAll('[data-role="status-chips"] .chip');
      chips.forEach(c => c.classList.remove('active'));
      
      // Clear comment
      const commentEl = card.querySelector('[data-role="comment"]');
      if (commentEl) commentEl.value = '';
      
      // Clear deadline
      const deadlineEl = card.querySelector('[data-role="deadline"]');
      if (deadlineEl) deadlineEl.value = '';
      
      // Clear give-up ID
      const giveUpIdEl = card.querySelector('[data-role="giveUpId"]');
      if (giveUpIdEl) giveUpIdEl.value = '';
      
      // Clear per-task assignee
      const taskAssigneeEl = card.querySelector('[data-role="task-assignee"]');
      if (taskAssigneeEl) taskAssigneeEl.value = '';
    });
    
    // Clear other task name
    if (taskNameInput) taskNameInput.value = '';
    
    // Clear audit text
    if (auditTextEl) auditTextEl.textContent = '';
    
    // Clear Last KYC date
    const lastKycEl = qs('#lastKycDate');
    if (lastKycEl) lastKycEl.textContent = '‚Äî';
    
    // Clear search results
    if (searchResults) {
      searchResults.classList.remove('visible');
      searchResults.innerHTML = '';
    }

    // Close email summary section
    if (emailSummarySection) {
      emailSummarySection.classList.remove('visible');
    }

    // Mark as new task for save logic
    currentRowNum = 'new';

    // Update email summary button state
    updateEmailSummaryButton();
    
    // Clear date displays
    updateDateDisplays();
    
    // Update visibility and placeholder
    syncTasksVisibility();
    updateExtraNotePlaceholder();

    // Autofocus first visible task comment field after a short delay
    setTimeout(() => {
      const visibleCard = document.querySelector('#taskCards .task-card:not([style*="display: none"]), #otherTaskCard:not([style*="display: none"])');
      if (visibleCard) {
        const commentEl = visibleCard.querySelector('[data-role="comment"]');
        if (commentEl && typeof commentEl.focus === 'function') {
          commentEl.focus();
        }
      }
    }, 100);
  }

  // Delete the current row from Excel
  async function deleteCurrentRow() {
    if (currentRowNum === null || currentRowNum === 'new') {
      throw new Error('No row to delete');
    }
    
    await Excel.run(async (context) => {
      const sheet = context.workbook.worksheets.getItemOrNullObject('TASK MANAGER FORM');
      sheet.load('name');
      await context.sync();
      
      if (sheet.isNullObject) {
        throw new Error('Sheet TASK MANAGER FORM not found');
      }
      
      // Delete the entire row
      const rowRange = sheet.getRange(`${currentRowNum}:${currentRowNum}`);
      rowRange.delete(Excel.DeleteShiftDirection.up);
      
      await context.sync();
      console.log('Deleted row', currentRowNum);
    });
  }

  // Add a new task to the next available row
  async function addNewTask() {
    await Excel.run(async (context) => {
      const sheet = context.workbook.worksheets.getItemOrNullObject('TASK MANAGER FORM');
      sheet.load('name');
      await context.sync();
      if (sheet.isNullObject) {
        console.error('Sheet TASK MANAGER FORM not found');
        return;
      }

      // Find the first empty row by scanning column A from row 2 onwards
      const colA = sheet.getRange('A2:A1000');
      colA.load('values');
      await context.sync();

      let nextRow = 2; // Start from row 2 (after header)
      const values = colA.values || [];
      for (let i = 0; i < values.length; i++) {
        if (values[i][0] && String(values[i][0]).trim() !== '') {
          nextRow = i + 3; // i is 0-indexed, row 2 is first data row, so next empty is i+2+1
        } else {
          // Found an empty cell
          nextRow = i + 2; // i is 0-indexed from row 2
          break;
        }
      }

      // Collect current form data
      const companyVal = companyNameInput ? companyNameInput.value.trim() : '';
      const descVal = getSelectedCategories().join(', ');
      const isOther = isOtherTaskSelected();
      const brokerVal = brokerLeadEl ? brokerLeadEl.value : '';
      const assignees = getSelectedAssignees().join(', ');

      // Write company name to column A
      sheet.getRange(`A${nextRow}`).values = [[companyVal]];
      // Write task category to column B
      sheet.getRange(`B${nextRow}`).values = [[descVal]];
      // Write assignees to column C
      sheet.getRange(`C${nextRow}`).values = [[assignees]];
      // Write broker lead to column D
      sheet.getRange(`D${nextRow}`).values = [[brokerVal]];

      // Write dates to columns E, F, G
      const dateE = formatDateForExcel(initialRequestInput ? initialRequestInput.value : '');
      const dateF = formatDateForExcel(introEmailInput ? introEmailInput.value : '');
      const dateG = formatDateForExcel(remindersStartInput ? remindersStartInput.value : '');
      sheet.getRange(`E${nextRow}:G${nextRow}`).values = [[dateE, dateF, dateG]];

      // Write Email Frequency (J) and Extra Note (K)
      sheet.getRange(`J${nextRow}`).values = [[emailFrequencyEl ? emailFrequencyEl.value : '']];
      sheet.getRange(`K${nextRow}`).values = [[extraNoteEl ? extraNoteEl.value : '']];

      // Helper to get today's date in d-MMM-yy format
      const getTodayFormatted = () => {
        const d = new Date();
        const months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
        return `${String(d.getDate()).padStart(2,'0')} ${months[d.getMonth()]} ${String(d.getFullYear()).slice(-2)}`;
      };
      const today = getTodayFormatted();

      // Build Column H from selected tasks
      const newTaskLines = [];
      if (isOther) {
        const otherCard = getTaskCard('__other__');
        const name = taskNameInput ? taskNameInput.value.trim() : '';
        if (name) {
          const status = getCardStatus(otherCard) || 'To Do';
          const commentEl = otherCard ? otherCard.querySelector('[data-role="comment"]') : null;
          const deadlineEl = otherCard ? otherCard.querySelector('[data-role="deadline"]') : null;
          const taskAssigneeEl = otherCard ? otherCard.querySelector('[data-role="task-assignee"]') : null;
          const taskAssignee = taskAssigneeEl && taskAssigneeEl.value ? taskAssigneeEl.value : assignees;
          
          // Set date based on status for new task
          let initiated = '', updated = '', completed = '';
          const statusLower = status.toLowerCase();
          if (statusLower === 'to do') {
            initiated = today;
          } else if (statusLower === 'in progress') {
            updated = today;
          } else if (statusLower === 'done') {
            completed = today;
          }
          
          const payload = {
            name,
            status,
            assignees: taskAssignee,
            comment: commentEl ? commentEl.value.trim() : '',
            giveUpId: '',
            initiated,
            updated,
            completed,
            deadline: deadlineEl ? deadlineEl.value : ''
          };
          newTaskLines.push(buildSummaryLine(payload));
        }
      } else {
        const toggles = getSelectedTaskToggles();
        const fixedNames = ['Broker Agreement','Give-up Agreement','Amend Annex A','KYC (produced by LCMC)','KYC External'];
        toggles.forEach(name => {
          if (!fixedNames.includes(name)) return;
          const card = getTaskCard(name);
          if (!card) return;
          const status = getCardStatus(card) || 'To Do';
          const commentEl = card.querySelector('[data-role="comment"]');
          const deadlineEl = card.querySelector('[data-role="deadline"]');
          const giveUpIdEl = card.querySelector('[data-role="giveUpId"]');
          const taskAssigneeEl = card.querySelector('[data-role="task-assignee"]');
          const taskAssignee = taskAssigneeEl && taskAssigneeEl.value ? taskAssigneeEl.value : assignees;
          
          // Set date based on status for new task
          let initiated = '', updated = '', completed = '';
          const statusLower = status.toLowerCase();
          if (statusLower === 'to do') {
            initiated = today;
          } else if (statusLower === 'in progress') {
            updated = today;
          } else if (statusLower === 'done') {
            completed = today;
          }
          
          const payload = {
            name,
            status,
            assignees: taskAssignee,
            comment: commentEl ? commentEl.value.trim() : '',
            giveUpId: giveUpIdEl ? giveUpIdEl.value.trim() : '',
            initiated,
            updated,
            completed,
            deadline: deadlineEl ? deadlineEl.value : ''
          };
          newTaskLines.push(buildSummaryLine(payload));
        });
      }

      const hRangeNew = sheet.getRange(`H${nextRow}`);
      hRangeNew.values = [[newTaskLines.join('\n')]];

      // Apply font color based on status priority: In Progress > To Do > Done
      // Use original Google Sheet colours: To Do #34a853, In Progress #ff9900, Done #cc6666
      if (newTaskLines.length > 0) {
        let hasInProgress = false;
        let hasToDo = false;
        let hasDone = false;
        
        newTaskLines.forEach(line => {
          const lower = line.toLowerCase();
          if (lower.includes(': in progress')) hasInProgress = true;
          else if (lower.includes(': to do')) hasToDo = true;
          else if (lower.includes(': done')) hasDone = true;
        });
        
        let fontColor;
        if (hasInProgress) {
          fontColor = '#ff9900'; // In Progress (orange)
        } else if (hasToDo) {
          fontColor = '#34a853'; // To Do (green)
        } else if (hasDone) {
          fontColor = '#cc6666'; // Done (soft red)
        } else {
          fontColor = '#34a853'; // default green
        }
        hRangeNew.format.font.color = fontColor;
      }

      await context.sync();

      // Select the new row so user can see it
      const newRowRange = sheet.getRange(`A${nextRow}`);
      newRowRange.select();
      await context.sync();

      // Update current row number for save logic
      currentRowNum = nextRow;
    });
  }

  // Update date display helpers to show d-MMM-yyyy format
  function updateDateDisplays() {
    const dateFields = [
      { input: '#initialRequest', display: '#initialRequestDisplay' },
      { input: '#introEmail', display: '#introEmailDisplay' },
      { input: '#remindersStart', display: '#remindersStartDisplay' }
    ];
    dateFields.forEach(({ input, display }) => {
      const inputEl = qs(input);
      const displayEl = qs(display);
      if (inputEl && displayEl) {
        const formatted = formatDateForDisplay(inputEl.value);
        displayEl.textContent = formatted ? `‚Üí ${formatted}` : '';
      }
    });
  }

  // Wire date inputs to update displays
  function wireDateInputs() {
    const dateInputs = ['#initialRequest', '#introEmail', '#remindersStart'];
    dateInputs.forEach(selector => {
      const el = qs(selector);
      if (el) {
        el.addEventListener('change', updateDateDisplays);
      }
    });
  }

  // Wire deadline inputs to update warnings
  function wireDeadlineInputs() {
    qsa('[data-role="deadline"]').forEach(input => {
      input.addEventListener('change', () => {
        applyDeadlineWarnings();
      });
    });
  }

  // ============== Email Summary Integration ==============

  const emailSummaryBtn = qs('#viewEmailSummaryBtn');
  const emailSummarySection = qs('#emailSummarySection');
  const emailSummaryList = qs('#emailSummaryList');
  const emailSummaryCount = qs('#emailSummaryCount');
  const closeEmailSummaryBtn = qs('#closeEmailSummaryBtn');

  // Update email summary button state based on company name
  function updateEmailSummaryButton() {
    const company = companyNameInput ? companyNameInput.value.trim() : '';
    if (emailSummaryBtn) {
      emailSummaryBtn.disabled = !company;
    }
  }

  // Wire company name input to update button state
  if (companyNameInput) {
    companyNameInput.addEventListener('input', updateEmailSummaryButton);
    companyNameInput.addEventListener('change', updateEmailSummaryButton);
  }

  // Wire email summary button click
  if (emailSummaryBtn) {
    emailSummaryBtn.addEventListener('click', async () => {
      await loadEmailSummaries();
    });
  }

  // Wire close button
  if (closeEmailSummaryBtn) {
    closeEmailSummaryBtn.addEventListener('click', () => {
      if (emailSummarySection) {
        emailSummarySection.classList.remove('visible');
      }
    });
  }

  // Load email summaries from the API
  async function loadEmailSummaries() {
    const company = companyNameInput ? companyNameInput.value.trim() : '';
    if (!company) {
      showToast('No company name entered', 'error');
      return;
    }

    // Show the section with loading state
    if (emailSummarySection) {
      emailSummarySection.classList.add('visible');
    }
    if (emailSummaryList) {
      emailSummaryList.innerHTML = '<div class="email-loading">Loading summaries...</div>';
    }

    try {
      const response = await fetch(
        `${EMAIL_SUMMARIZER_API_URL}/api/task-manager/summaries/${encodeURIComponent(company)}?include_drafts=true`
      );

      if (!response.ok) {
        throw new Error(`Server returned ${response.status}`);
      }

      const data = await response.json();
      const summaries = data.summaries || [];

      // Update count badge
      if (emailSummaryCount) {
        emailSummaryCount.textContent = summaries.length;
      }

      // Render summaries
      if (summaries.length === 0) {
        emailSummaryList.innerHTML = '<div class="email-no-summaries">No email summaries found for this company.</div>';
        return;
      }

      emailSummaryList.innerHTML = summaries.map(s => `
        <div class="email-summary-item ${s.is_draft ? 'draft' : 'confirmed'}" data-id="${s.id}">
          <div class="email-summary-subject">
            ${escapeHtml(s.subject || 'No subject')}
            ${s.is_draft ? '<span class="draft-badge">Draft</span>' : ''}
          </div>
          <div class="email-summary-meta">
            From: ${escapeHtml(s.from || 'Unknown')} | ${formatEmailDate(s.date)}
          </div>
          <div class="email-summary-text">${escapeHtml(s.summary || 'No summary available')}</div>
          ${s.is_draft ? `
            <div class="email-summary-actions">
              <button class="btn-confirm-summary" onclick="window.confirmEmailSummary(${s.id})">
                ‚úì Confirm & Link to Task
              </button>
            </div>
          ` : ''}
        </div>
      `).join('');

    } catch (err) {
      console.error('Error loading email summaries:', err);
      if (emailSummaryList) {
        emailSummaryList.innerHTML = `<div class="email-no-summaries">Error loading summaries: ${escapeHtml(err.message)}<br><small>Make sure the Email Summarizer service is running.</small></div>`;
      }
    }
  }

  // Format date for display
  function formatEmailDate(dateStr) {
    if (!dateStr) return 'Unknown date';
    try {
      const d = new Date(dateStr);
      if (isNaN(d.getTime())) return dateStr;
      return d.toLocaleDateString('en-GB', { day: '2-digit', month: 'short', year: 'numeric' });
    } catch (e) {
      return dateStr;
    }
  }

  // Confirm a draft summary and link it to the current task
  window.confirmEmailSummary = async function(summaryId) {
    if (currentRowNum === null || currentRowNum === 'new') {
      showToast('Please save the task first', 'error');
      return;
    }

    try {
      // Call the API to confirm the summary
      const response = await fetch(`${EMAIL_SUMMARIZER_API_URL}/api/task-manager/confirm/${summaryId}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ task_row: currentRowNum })
      });

      if (!response.ok) {
        throw new Error(`Server returned ${response.status}`);
      }

      // Write summary reference to column L in Excel
      await Excel.run(async (context) => {
        const sheet = context.workbook.worksheets.getItemOrNullObject('TASK MANAGER FORM');
        sheet.load('name');
        await context.sync();

        if (sheet.isNullObject) {
          throw new Error('Sheet not found');
        }

        const cell = sheet.getRange(`L${currentRowNum}`);
        cell.load('values');
        await context.sync();

        // Append or create new reference
        const existing = (cell.values && cell.values[0] && cell.values[0][0])
          ? String(cell.values[0][0])
          : '';
        const newRef = `[Email Summary #${summaryId}]`;
        cell.values = [[existing ? `${existing} ${newRef}` : newRef]];
        await context.sync();
      });

      showToast('Summary confirmed and linked!', 'success');

      // Reload summaries to reflect the change
      await loadEmailSummaries();

    } catch (err) {
      console.error('Error confirming summary:', err);
      showToast('Error confirming summary: ' + err.message, 'error');
    }
  };

  // Initial load when Office host is ready
  if (typeof Office !== 'undefined' && typeof Office.onReady === 'function') {
  
      Office.onReady((info) => {
        if (info.host === Office.HostType.Excel) {
          wireCardChips();
          wireDateInputs();
          wireDeadlineInputs(); // Wire deadline warnings
          wireChangeTracking(); // Track unsaved changes
        // Wire task checkbox visibility
        qsa('#tasksChecklist .task-toggle').forEach(cb => {
          cb.addEventListener('change', () => syncTasksVisibility());
        });
        // Wire category checkbox visibility
        qsa('#taskCategories .category-toggle').forEach(cb => {
          cb.addEventListener('change', () => syncTasksVisibility());
        });
        loadFromActiveRow().then(() => {
          // Reset unsaved indicator after initial load
          setUnsavedChanges(false);
          // Auto-load active tasks on startup
          performSearch();
        });
      }
    });
  }
})();
